# Java 开发手册

# Java 开发手册

会当凌绝顶，一览众山小。

---

# 前言

《Java 开发手册》是阿里巴巴集团技术团队的集体智慧结晶和经验总结，经历了多次大规模一线实战的检验及不断完善，公开到业界后，众多社区开发者踊跃参与，共同打磨完善，系统化地整理成册，当前的版本是豪礼版。现代软件行业的高速发展对开发者的综合素质要求越来越高，因为不仅是编程知识点，其它维度的知识点也会影响到软件的最终交付质量。比如：数据结构表结构的柔韧设计缺陷可能带来软件上的架构缺陷或性能风险；工程结构的混乱导致后续维护困难；没有监控的后门代码易被黑客攻击甚至等等。所以本手册以 Java 开发者为中心视角，划分为编程规约、异常日志、单元测试、安全规约、MySQL 数据库、工程结构、设计规约七个维度，骨根据内容粒化，细分成若干二级子目录。另外，依据约束力强弱及故障敏性，规约依次分为强制、推荐、参考三大类。在逻辑信息中，“说明”对规约做了适当扩展和解释；“正例”提供什么样的编程和实现方式；“反例”说明需要提防的雷区，以及真实的错误案例。

手册的愿景是码出高效，码出质量。现代软件架构的复杂性需要协同开发完成，如何高效地协同？无规矩不成方圆，无规范难以协同，故以，制订这规范是主要限制存在，实际上是为了给团队的人身安全，试想如果没有限制，某个开发者在代码中随意插入一个外来求，通常情况下标准绝不是消灭代码内容的创造性、优雅性，而是限制过度个性化，以一种普遍认可的统一方式一起做事，提升协作效率，降低沟通成本。代码的字里行间流淌的是软件系统的血液，质量的提升是尽可能少踩坑，杜绝冗重复的坑，切实提升系统稳定性，码出质量。

我们已经在2017 杭州云栖大会上发布了配套的 [Java 开发规约 IDE 插件](https://www.aliyun.com/product/ide)，下载量达到 152 万人次，阿里云效也集成了代码规约的扫描引擎。次年，发布 36 万字的配套详细解图书《码出高效》，本书秉持“图胜于表，表胜于言”的理念，深入浅出地将计算机基础、面向对象思想、JVM 探源、数据结构与集合、并发与多线程、单元测试等知识客观、立体地呈现出来。紧扣学习致用，学以致进的目标，结合阿里巴巴实践经验和故障案例，与底层源码解析融会贯通，娓娓道来。《码出高效》和《Java 开发手册》书籍版所取得令人均拥趸公益事情，希望期技术情怀帮助更多的人。

---

# 目录

前 言..................................................................................................................1

一、编程规约........................................................................................................1

（一）命名风格....................................................................................................1

（二）常量定义....................................................................................................4

（三）代码格式....................................................................................................5

（四）OOP规约....................................................................................................7

（五）日期时间..................................................................................................11

（六）集合处理..................................................................................................12

（七）并发处理..................................................................................................17

（八）控制语句..................................................................................................20

（九）注释规约..................................................................................................24

（十）其它..........................................................................................................25

二、异常日志......................................................................................................27

（一）错误码......................................................................................................27

（二）异常处理..................................................................................................28

（三）日志规约..................................................................................................30

三、单元测试......................................................................................................33

四、安全规约......................................................................................................35

五、MySQL数据库............................................................................................36

（一）建表规约..................................................................................................36

（二）索引规约..................................................................................................37

（三）SQL语句..................................................................................................39

（四）ORM映射................................................................................................40

六、工程结构......................................................................................................42

（一）应用分层..................................................................................................42

（二）二方库依赖..............................................................................................43

（三）服务器......................................................................................................44

七、设计规约......................................................................................................46

附1：版本历史..................................................................................................49

附2：专有名词解释..........................................................................................51

附3：错误码列表..............................................................................................52

（注：浏览时请使用PDF左侧导航栏）

---

# 一、编程规约
## (一) 命名风格
1. **[强制]** 代码中的命名均不能以下划线或美元符号开头，也不能以下划线或美元符号结尾。
   反例：_name / __name / $name / name_ / name$ / name__

2. **[强制]** 所有编程相关的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。
   说明：正确的英文拼写和语法可以让阅读者易于理解，避免歧义。注意，纯拼音命名方式要避免采用。
   正例：ali / alibaba / taobao / cainiao / aliyun/ youku / hangzhou 等国际通用的名称，可视同英文。
   反例：DaZhePromotion [打折] / getPingfenByName() [评分] / int 某变量 = 3

3. **[强制]** 类名使用 UpperCamelCase 风格，但以下情形例外：DO / BO / DTO / VO / AO / PO / UID 等。
   正例：ForceCode / UserDO / HtmlDTO / XmlService / TcpUdpDeal / TaPromotion
   反例：forcecode / UserDo / HTMLDto / XMLService / TCPUDPDeal / TAPromotion

4. **[强制]** 方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格。
   正例：localValue / getHttpMessage() / inputUserId

5. **[强制]** 常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。
   正例：MAX_STOCK_COUNT / CACHE_EXPIRED_TIME
   反例：MAX_COUNT / EXPIRED_TIME

6. **[强制]** 抽象类命名使用 Abstract 或 Base 开头；异常类命名使用 Exception 结尾；测试类命名以它要测试的类的名称开头，以 Test 结尾。

7. **[强制]** 类型与中括号紧挨相连来表示数组。
   正例：定义整型数组 int[] arrayDemo;
   反例：在 main 参数中，使用 String args[]来定义。

8. **[强制]** POJO 类中的任何布尔类型的变量，都不要加 is 前缀，否则部分框架解析会引起序列化错误。
   说明：在本文 MySQL 规约的建表字段定义部分，表达是否的概念是 xxx_yn 的方式，所以，需要在<resultMap>中设置<is_xxx 到 xxx 的映射关系>。

---

### (三) 代码格式

1. **【强制】** 如果是大括号内为空，则简洁地写成{}即可，大括号中间无需换行和空格；如果是非空代码块则：
   1）左大括号前不换行。
   2）左大括号后换行。
   3）右大括号前换行。
   4）右大括号后还有 else 等代码则不换行；表示终止的右大括号后必须换行。

2. **【强制】** 左小括号和左边相邻字符之间不出现空格；右小括号和左边相邻字符之间也不出现空格；而左大括号前需要加空格。详见第 5 条下方正例提示。
   反例：if (空格a == b空格)

3. **【强制】** if/for/while/switch/do 等保留字与括号之间都必须加空格。

4. **【强制】** 任何二目、三目运算符的左右两边都需要加一个空格。
   说明：包括赋值运算符、逻辑运算符&&、加减乘除等。

5. **【强制】** 采用 4 个空格缩进，禁止使用 tab 字符。
   说明：如果使用 tab 缩进，必须设置 1 个 tab 为 4 个空格。IDEA 设置 tab 为 4 个空格时，请勿勾选 Use tab character；而在 eclipse 中，必须勾选 insert spaces for tabs。
   正例：（涉及 1-5 点）

```java
public static void main(String[] args) {
    // 缩进 4 个空格
    String say = "hello";
    // 运算符的左右必须有一个空格
    int flag = 0;
    // 关键语句与括号之间必须有一个空格，括号内的与左括号、0、与右括号不需要空格
    if (flag == 0) {
        System.out.println(say);
    }
    // 左大括号前加空格且不换行；左大括号后换行
    if (flag == 1) {
        System.out.println("world");
    // 右大括号前换行，右大括号后有 else，不用换行
    } else {
        System.out.println("ok");
    }
    // 在右大括号后换行表示终止，则必须换行
}
```


---

# Java 开发手册

13. **【推荐】** 在常量与变量的命名时，表示类型的名词放在词尾，以提升辨识度。

**正例：** startTime / workQueue / nameList / TERMINATED_THREAD_COUNT

**反例：** startedAt / QueueOfWork / listName / COUNT_TERMINATED_THREAD

14. **【推荐】** 如果模块、接口、类、方法使用了设计模式，在命名时需体现出具体模式。

**说明：** 将设计模式体现在名字中，有利于阅读者快速理解架构设计理念。

**正例：**

```java
public class OrderFactory;
public class LoginProxy;
public class ResourceObserver;
```

15. **【推荐】** 接口类中的方法和属性不要加任何修饰符号（public 也不要加），保持代码的简洁性，并加上有效的 Javadoc 注释。尽量不要在接口里定义变量，如果一定要定义变量，确定与接口方法相关，并且是整个应用的基础常量。

**正例：**

- 接口方法签名 void commit();
- 接口基础常量 String COMPANY = "alibaba";

**反例：**

- 接口方法定义 public abstract void f();

**说明：** JDK8 中接口允许有默认实现，那么这个 default 方法，是对所有实现类都有价值的默认实现。

16. 接口和实现类的命名有两套规则：

1） **【强制】** 对于 Service 和 DAO 类，基于 SOA 思想暴露出来的服务一定是接口，内部的实现类用 Impl 的后缀与接口区别。

**正例：** CacheServiceImpl 实现 CacheService 接口。

2） **【推荐】** 如果是形容能力的接口名称，取对的形容词为接口名（通常是 -able 的形容词）。

**正例：** AbstractTranslator 实现 Translatable 接口。

17. **【参考】** 枚举类名带上 Enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开。

**说明：** 枚举类其实就是特殊的常量类，目的是方法被调用时强制是私有。

**正例：** 枚举名字为 ProcessStatusEnum 的成员名称：SUCCESS / UNKNOWN_REASON。

18. **【参考】** 各层命名规约：

A) Service/DAO 层方法命名规约

1） 获取单个对象的方法用 get 做前缀。
2） 获取多个对象的方法用 list 做前缀，复数结尾，如：listObjects。
3） 获取统计值的方法用 count 做前缀。
4） 插入的方法用 save/insert 做前缀。
5） 删除的方法用 remove/delete 做前缀。
6） 修改的方法用 update 做前缀。

B) 领域命名规约

1） 数据对象：xxxDO，xxx 即为数据表名。
2） 数据传输对象：xxxDTO，xxx 为业务领域相关的名称。

---

## (二) 常量定义

1. **【强制】** 不允许任何魔法值（即未经过预先定义的常量）直接出现在代码中。
   
   **反例：**
   ```java
   String key = "Id#taobao_" + tradeId;
   cache.put(key, value);
   ```

2. **【强制】** 在 long 或者 Long 赋值时，数值后使用大写的 L，不能是小写的 l，小写容易跟数字混淆，造成误解。
   
   **说明：** Long a = 2l; 写的是数字的 21，还是 Long 型的 2。

3. **【推荐】** 不要使用一个常量类维护所有常量，要按常量功能进行归类，分开维护。
   
   **说明：** 太庞杂的常量类，杂乱无章，使用查找功能才能定位到该常量，不利于理解，也不利于维护。
   
   **正例：** 缓存相关常量放在类 CacheConsts 下；系统配置相关常量放在类 ConfigConsts 下。

4. **【推荐】** 常量的复用层次有五层：跨应用共享常量、应用内共享常量、子工程内共享常量、包内共享常量、类内共享常量。
   
   1）跨应用共享常量：放置在一方中，通常是 client.jar 中的 constant 目录下。
   
   2）应用内共享常量：放置在一方中，通常是子模块中的 constant 目录下。
   
   **反例：**
   ```java
   类 A 中：public static final String YES = "yes";
   类 B 中：public static final String YES = "y";
   A.YES.equals(B.YES)，预期是 true，但实际返回为 false，导致线上问题。
   ```
   
   3）子工程内的共享常量：即在当前子工程的 constant 目录下。
   
   4）包内共享常量：即在当前包下单独的 constant 目录下。
   
   5）类内共享常量：直接在类内部的 private static final 定义。

5. **【推荐】** 如果变量值仅在一个固定范围内变化使用 enum 类型来定义。
   
   **说明：** 如果存在名称之外的延伸属性应使用 enum 类型，下面正例中的数字就是延伸信息，表示一年中的第几个季节。
   
   **正例：**
   ```java
   public enum SeasonEnum {
       SPRING(1), SUMMER(2), AUTUMN(3), WINTER(4);
       private int seq;
       SeasonEnum(int seq) {
           this.seq = seq;
       }
       public int getSeq() {
           return seq;
       }
   }
   ```

## 第8页（处理失败）



---

## Java 开发手册

6. **【强制】** 注释的双斜线与注释内容之间有且仅有一个空格。

**正例**：

```java
// 这是示例注释，请注意在双斜线之后有一个空格
String commentString = new String();
```

7. **【强制】** 在进行类型强制转换时，右括号与强制转换值之间不需要任何空格隔开。

**正例**：

```java
long first = 1000000000000L;
int second = (int)first + 2;
```

8. **【强制】** 单行字符串长度不超过 120 个，超过需要换行，换行时遵循如下原则：

1）第一行相对第一行缩进 4 个空格，从第三行开始，不再继续缩进，参考示例。

2）运算符与下一行一起换行。

3）方法调用的点符号与下一行一起换行。

4）方法调用中的多个参数需要换行时，在逗号后进行。

5）在括号前不要换行，**反例**。

**正例**：

```java
StringBuilder sb = new StringBuilder();
// 超过 120 个字符的情况下，纯手动缩进 4 个空格，并且方法的点号一起换行
sb.append("zi").append("xin")...
    .append("huang")...
    .append("huang")...
    .append("huang");
```

**反例**：

```java
StringBuilder sb = new StringBuilder();
// 超过 120 个字符的情况下，不要在括号前换行
sb.append("you").append("are")...append
    ("lucky");

// 参数很多的方法调用可能超过 120 个字符，逗号后才是换行处
method(args1, args2, args3, ...
    ,argsX);
```

9. **【强制】** 方法参数在定义和传入时，多个参数逗号后边必须加空格。

**正例**：下例中参数 `args1`，后边必须要有一个空格。

```java
method(args1, args2, args3);
```

10. **【强制】** IDE 的 text file encoding 设置为 UTF-8；IDE 中文件的换行符使用 Unix 格式，不要使用 Windows 格式。

11. **【推荐】** 单个方法的行数不超过 80 行。

**说明**：除注释之外的方法签名、左右大括号、方法内代码、空行、回车及任何不可见字符的总行数不超过 80 行。

**正例**：代码逻辑分清在代码块中，个性和共性，绿叶逻辑单独出来成为独立的方法，使主干代码更加清晰；共性逻辑抽取成为共性方法，便于复用和维护。

---

## 20. 【推荐】类内方法定义的顺序依次是：公有方法或保护方法 > 私有方法 > getter / setter 方法。
说明：公有方法是类的调用者和维护者最关心的方法，首屏展示最好；保护方法虽然是子类关心，也可能是“模板设计模式”下的核心方法；而私有方法外部一般不需要特别关心，是一个黑盒实现；因为承载的信息价值较低，所有 Service 和 DAO 的 getter/setter 方法放在类体最后。

### 反例：
```java
public Integer getData() {
    if (condition) {
        return this.data + 100;
    } else {
        return this.data - 100;
    }
}
```

## 21. 【推荐】setter 方法中，参数名称与类成员变量名称一致，this.成员名 = 参数名。在 getter/setter 方法中，不要增加业务逻辑，增加排查问题的难度。

## 22. 【推荐】循环体内，字符串的连接方式，使用 StringBuilder 的 append 方法进行扩展。
说明：不例中，反编译出的字节码文件显示每次循环都会 new 出一个 StringBuilder 对象，然后进行 append 操作，最后通过 toString 方法返回 String 对象，造成内存资源浪费。

### 反例：
```java
String str = "start";
for (int i = 0; i < 100; i++) {
    str += "hello";
}
```

## 23. 【推荐】final 可以声明类、成员变量、方法，以及本地变量，下列情况使用 final 关键字：
1. 不允许被继承的类，如：String 类。
2. 不允许修改引用的域对象，如：POJO 类的域变量。
3. 不允许被覆写的方法，如：POJO 类的 setter 方法。
4. 不允许运行过程中重新赋值的局部变量。
5. 避免上下文重叠使用一个变量，使用 final 可以强制重新定义一个变量，方便更好地进行重构。

## 24. 【推荐】慎用 Object 的 clone 方法来拷贝对象。
说明：对象 clone 方法默认是浅拷贝，若想实现深拷贝需重写 clone 方法实现域对象的深度遍历式拷贝。

## 25. 【推荐】类成员与方法访问控制严格：
1. 如果不允许外部直接通过 new 来创建对象，那么构造方法必须是 private。
2. 工具类不允许有 public 或 default 构造方法。
3. 类中的成员变量如果对子类可见，必须是 protected。
4. 类的成员变量如果仅在本类使用，必须是 private。
5. 类的成员变量如果在本类使用，必须是 private。
6. 若是独立成段变量，考虑是否为 final。

---

# Java 开发手册

8. **【强制】** 任何货币金额，均以最小货币单位且整型类型来进行存储。

9. **【强制】** 浮点数之间的等值判断，基本数据类型不能用`==`来比较，包装数据类型不能用`equals`来判断。

   说明：浮点数采用“尾数+阶码”的编码方式，类似于科学计数法的“有效数字+指数”的表示方式。二进制无法精确表示大部分的十进制小数，具体原理参考[码出高效](https://example.com)。

   **反例：**
   ```java
   float a = 1.0f - 0.9f;
   float b = 0.9f - 0.8f;

   if (a == b) {
       // 预期进入此代码块，执行其它业务逻辑
       // 但事实上 a == b 的结果为 false
   }

   Float x = Float.valueOf(a);
   Float y = Float.valueOf(b);
   if (x.equals(y)) {
       // 预期进入此代码块，执行其它业务逻辑
       // 但事实上 equals 的结果为 false
   }
   ```

   **正例：**
   1. 指定一个误差范围，两个浮点数的差值在此范围之内，认为是相等的。
   ```java
   float a = 1.0f - 0.9f;
   float b = 0.9f - 0.8f;
   float diff = 1e-6f;

   if (Math.abs(a - b) < diff) {
       System.out.println("true");
   }
   ```

   2. 使用 BigDecimal 来定义值，再进行浮点数的运算操作。
   ```java
   BigDecimal a = new BigDecimal("1.0");
   BigDecimal b = new BigDecimal("0.9");
   BigDecimal c = new BigDecimal("0.8");

   BigDecimal x = a.subtract(b);
   BigDecimal y = b.subtract(c);

   if (x.equals(y)) {
       System.out.println("true");
   }
   ```

10. **【强制】** 定义数据对象 DO 类时，属性类型要与数据库字段类型相匹配。

    **正例：** 数据库字段的 bigint 必须与类属性的 Long 类型相对应。

    **反例：** 某个案例的数据表 id 字段定义类型 bigint unsigned，实际类对象属性为 Integer，随着 id 越来
    越大，超过 Integer 的表示范围而导致溢出成为负数。

11. **【强制】** 禁止使用构造方法 BigDecimal(double) 的方式把 double 值转化为 BigDecimal 对象。

    说明：BigDecimal(double)存在精度损失风险，在精确计算或比较的场景中可能会导致业务逻辑异常。

---

### Java 开发手册

**正例：**

```java
// 获取今年的天数
int daysOfThisYear = LocalDate.now().lengthOfYear();

// 获取指定某年的天数
LocalDate.of(2011, 1, 1).lengthOfYear();
```

**反例：**

```java
// 第一种情况：在闰年 366 天时，出现数据结果异常
int[] dayArray = new int[365];

// 第二种情况：一年有闰年的会员制，今年 1 月 26 日注册，硬编码 365 返回的却是 1 月 25 日
Calendar calendar = Calendar.getInstance();
calendar.set(2020, 1, 26);
calendar.add(Calendar.DATE, 365);
```

6. **【推荐】** 避免公历闰年 2 月问题。闰年的 2 月份有 29 天，一年后的那一天不可能是 2 月 29 日。

7. **【推荐】** 使用枚举值来指代月份。如果使用数字，注意 Date，Calendar 等日期相关类的月份 month 取值在 0-11 之间。

**说明：** 参考 JDK 原生注释，Month value is 0-based. e.g., 0 for January.

**正例：** Calendar.JANUARY，Calendar.FEBRUARY，Calendar.MARCH 等来指代相应月份来进行传参或比较。

---

## (六) 集合处理

1. **【强制】** 关于 hashCode 和 equals 的处理，遵循如下规则：

   1）只要重写 equals，就必须重写 hashCode。

   2）因为 Set 存储的是不重复的对象，依据 hashCode 和 equals 进行判断，所以 Set 存储的对象必须重写这两个方法。

   3）如果自定义对象作为 Map 的键，那么必须重写 hashCode 和 equals。

**说明：** String 因为重写了 hashCode 和 equals 方法，所以我们可以愉快地使用 String 对象作为 key 来使用。

2. **【强制】** 判断所有集合内部的元素是否为空，使用 isEmpty() 方法，而不是 size()==0 的方式。

**说明：** 前者的时间复杂度为 O(1)，而后可读性更好。

**正例：**

```java
Map<String, Object> map = new HashMap<>();
if(map.isEmpty()) {
    System.out.println("no element in this map.");
}
```


## 第13页（处理失败）



---

## (五) 日期时间

1. **【强制】** 日期格式化时，传入 pattern 中表示年份统一使用小写的 y。

   **说明：** 日期格式化时，yyyy 表示当年所在的年份，而大写的 YYYY 代表是 week in which year（JDK7 之后引入的概念），意思是当某天所在的周属于的年份，一周从周日开始，周六结束，只要本周跨年，返回的 YYYY 就是下一年。

   **正例：** 表示日期和时间的格式如下所示：

   ```java
   new SimpleDateFormat("yyyy-MM-dd HH:mm:ss")
   ```

2. **【强制】** 在日期格式中区分清楚大写的 M 和小写的 m，大写的 H 和小写的 h 分别指代的意义。

   **说明：** 日期格式中的这两对字母表示如下：

   1）表示月份是大写的 M；

   2）表示分钟则是小写的 m；

   3）24 小时制的是大写的 H；

   4）12 小时制的则是小写的 h。

3. **【强制】** 获取当前毫秒数：System.currentTimeMillis() 而不是 new Date().getTime()。

   **说明：** 如果想获取更加精确的纳秒级时间值，使用 System.nanoTime() 方式。在 JDK8 中，针对统计时间等场景，推荐使用 Instant 类。

4. **【强制】** 不允许在程序任何地方中使用：1）java.sql.Date 2）java.sql.Time 3）java.sql.Timestamp。

   **说明：** 第 1 个不记录时间，getHours() 抛出异常；第 2 个不记录日期，getYear() 抛出异常；第 3 个在构造方法 super((time/1000)*1000)，fastTime 和 nanos 分开存储和校准信息。

   **反例：** java.util.Date.after(Date) 进行时间比较时，当入参是 java.sql.Timestamp 时，会触发 JDK BUG(JDK9 已修复)，可能导致比较的高余位结果。

5. **【强制】** 不要在程序中写死一年为 365 天，避免在公历闰年时出现日期转换错误或是程序逻辑错误。

---

### 14. **[强制]** 不要在 foreach 循环里进行元素的 remove/add 操作。remove 元素请使用 Iterator 方式，如果并发操作，需要对 Iterator 对象加锁。

**正例：**
```java
List<String> list = new ArrayList<>();
list.add("1");
list.add("2");
Iterator<String> iterator = list.iterator();
while (iterator.hasNext()) {
    String item = iterator.next();
    if (删除元素的条件) {
        iterator.remove();
    }
}
```

**反例：**
```java
for (String item : list) {
    if ("1".equals(item)) {
        list.remove(item);
    }
}
```

**说明：**以上代码的执行结果肯定会出乎大家的意料，那么试一下把 "1" 换成 "2"，会是同样的结果吗？

### 15. **[强制]** 在 JDK7 版本及以上，Comparator 实现类要满足如下三个条件，否则 Arrays.sort，Collections.sort 会抛 IllegalArgumentException 异常。

**说明：**三个条件如下
1. x，y 的比较结果和 y，x 的比较结果相反。
2. x>y，y>z，则 x>z。
3. x=y，则 x，z 比较结果和 y，z 比较结果相同。

**反例：**下例中没有处理相等的情况，交换两个对象判断结果并不相反，不符合第一个条件，在实际使用中可能会抛出异常。
```java
new Comparator<Student>() {
    @Override
    public int compare(Student o1, Student o2) {
        return o1.getId() > o2.getId() ? 1 : -1;
    }
}
```

### 16. **[推荐]** 集合泛型定义时，在 JDK7 及以上，使用 diamond 语法或者省略。

**说明：**菱形泛型，即 diamond，直接使用<>来指代前边已经指定的类型。

---

### 3. **[强制]** 在使用 java.util.stream.Collectors 类的 toMap()方法转为 Map 集合时，一定要使用含有参数类型为 BinaryOperator，参数名为 mergeFunction 的方法，否则当出现相同 key 值时会抛出 IllegalStateException 异常。

说明：参数 mergeFunction 的作用是当出现 key 重复时，自定义对 value 的处理策略。

**正例**：
```java
List<Pair<String, Double>> pairArrayList = new ArrayList<>(3);
pairArrayList.add(new Pair<>("version", 6.19));
pairArrayList.add(new Pair<>("version", 10.24));
pairArrayList.add(new Pair<>("version", 2.13));
Map<String, Double> map = pairArrayList.stream().collect(
    // 处理每个集合元素的映射关系 {version: 10.24}
    Collectors.toMap(Pair::getKey, Pair::getValue, (v1, v2) -> v2));
```

**反例**：
```java
String[] departments = new String[] {"iERP", "iERP", "EIBU"};
// 抛出 IllegalStateException 异常
Map<Integer, String> map = Arrays.stream(departments)
    .collect(Collectors.toMap(String::hashCode, str -> str));
```

### 4. **[强制]** 在使用 java.util.stream.Collectors 类的 toMap()方法转为 Map 集合时，一定要注意 value 为 null 时会抛 NPE 异常。

说明：在 java.util.HashMap 的 merge 方法里是会进行如下的判断：
```java
if (value == null || remappingFunction == null)
    throw new NullPointerException();
```

**反例**：
```java
List<Pair<String, Double>> pairArrayList = new ArrayList<>(2);
pairArrayList.add(new Pair<>("version1", 4.22));
pairArrayList.add(new Pair<>("version2", null));
Map<String, Double> map = pairArrayList.stream().collect(
    // 抛出 NullPointerException 异常
    Collectors.toMap(Pair::getKey, Pair::getValue, (v1, v2) -> v2));
```

### 5. **[强制]** ArrayList 的 subList 结果不可强转成 ArrayList，否则会抛出 ClassCastException 异常：java.util.RandomAccessSubList cannot be cast to java.util.ArrayList。

说明：subList 返回的是 ArrayList 的内部类 SubList，并不是 ArrayList 而是 ArrayList 的一个视图，对于 SubList 子列表的所有操作最终会反映到原列表上。

### 6. **[强制]** 使用 Map 的方法 keySet()/values()/entrySet()返回集合对象时，不可以对其进行增加元素操作，否则会抛出 UnsupportedOperationException 异常。

### 7. **[强制]** Collections 类返回的对象，如：emptyList()/singletonList()等都是 immutable list，不可对其进行添加或替换删除元素的操作。

**反例**：如果查询无结果，返回 Collections.emptyList()空集合对象，调用方一旦进行添加元素的操作，就会触发 UnsupportedOperationException 异常。

---

## (七) 并发处理

1. **[强制]** 获取单例对象需要保证线程安全，其中的方法也要保证线程安全。
   说明：资源驱动类、工具类、单例工厂类都需要注意。

2. **[强制]** 创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。
   正例：自定义线程工厂，并且根据外部特征进行分组，比如，来自同一机房的调用，机房编号赋值给whatFeaturOfGroup

   ```java
   public class UserThreadFactory implements ThreadFactory {
       private final String namePrefix;
       private final AtomicInteger nextId = new AtomicInteger(1);

       // 定义线程名称，在 jstack 问题排查时，非常有帮助
       UserThreadFactory(String whatFeaturOfGroup) {
           namePrefix = "From UserThreadFactory's " + whatFeaturOfGroup + "-Worker-";
       }

       @Override
       public Thread newThread(Runnable task) {
           String name = namePrefix + nextId.getAndIncrement();
           Thread thread = new Thread(null, task, name, 0, false);
           System.out.println(thread.getName());
           return thread;
       }
   }
   ```

3. **[强制]** 线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。
   说明：线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源的开销，并解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量类似线程而导致内存耗尽或者“过度切换”的问题。

4. **[强制]** 线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。
   说明：Executors 返回的线程池对象弊端如下：
   1）FixedThreadPool 和 SingleThreadPool：
   允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。
   2）CachedThreadPool：
   允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。

5. **[强制]** SimpleDateFormat 是线程不安全的类，一般不要定义为 static 变量，如果定义为 static，必须加锁，或者使用 DateUtils 工具类。
   正例：注意线程安全，使用 DateUtils，亦推荐如下处理：

   ```java
   private static final ThreadLocal<DateFormat> df = new ThreadLocal<DateFormat>() {
       @Override
       protected DateFormat initialValue() {
           return new SimpleDateFormat("yyyy-MM-dd");
       }
   };
   ```

## 第18页（处理失败）



---

# Java 开发手册

**正例**：

```java
// diamond 方式，即 <>
HashMap<String, String> userCache = new HashMap<>(16);
// 全省略方式
ArrayList<User> users = new ArrayList<>(10);
```

17. **[推荐]** 集合初始化时，指定集合初始值大小。

**说明**：HashMap 使用 HashMap(int initialCapacity) 初始化，如果暂时无法确定集合大小，那么指定默认值（16）即可。

**正例**：initialCapacity = (需要存储的元素个数 / 负载因子) + 1。注意负载因子（即 loader factor）默认为 0.75，如果暂时无法确定初始值大小，请设置为 16（即默认值）。

**反例**：HashMap 需要放置 1024 个元素，由于没有设置集合初始大小，随着元素不断增加，容量 7 次被迫扩充，resize 需要重建 hash 表，当放置的集合元素数目达到千万级别时，不断扩容严重影响性能。

18. **[推荐]** 使用 entrySet 遍历 Map 类集合 K/V，而不是 keySet 方式进行遍历。

**说明**：keySet 其实是遍历了 2 次，一次是转为 Iterator 对象，另一次是从 hashMap 中取出 key 所对应的 value，而 entrySet 只是遍历了一次就把 key 和 value 都放到了 entry 中，效率更高。如果是 JDK8，使用 Map.forEach 方法。

**正例**：values()返回的是 V 值集合，是一个 list 集合对象；keySet()返回的是 K 值集合，是一个 Set 集合对象；entrySet()返回的是 K-V 值的集合。

19. **[推荐]** 高度注意 Map 类集合 K/V 能不能存储 null 值的情况，如下表格：

| 集合类              | Key          | Value        | Super        | 说明           |
|--------------------|--------------|--------------|--------------|----------------|
| Hashtable          | 不允许为 null | 不允许为 null | Dictionary   | 线程安全       |
| ConcurrentHashMap  | 不允许为 null | 不允许为 null | AbstractMap  | 锁分段技术（JDK8:CAS） |
| TreeMap            | 不允许为 null | 允许为 null   | AbstractMap  | 线程不安全     |
| HashMap            | 允许为 null   | 允许为 null   | AbstractMap  | 线程不安全     |

**反例**：由于 HashMap 的干扰，很多人认为 ConcurrentHashMap 是可以置入 null 值， 而事实上，存储 null 值时会抛出 NPE 异常。

20. **[参考]** 合理利用好集合的有序性(sort)和稳定性(order)，避免集合的无序性(unsort)和不稳定性(unorder)带来的负面影响。

**说明**：有序性是指遍历的结果是按某种比较规则依次排列的。稳定性指集合每次遍历的元素次序是一定的。如：ArrayList 是 order/unsort；HashMap 是 unorder/unsort；TreeSet 是 order/sort。

21. **[参考]** 利用 Set 元素唯一的特性，可以快速对一个集合进行去重操作，避免使用 List 的 contains()进行遍历去重或者判断包含操作。

## 第20页（处理失败）



---

# Java 开发手册

说明：如果是 JDK8 的应用，可以使用 Instant 代替 Date，LocalDateTime 代替 Calendar，DateTimeFormatter 代替 SimpleDateFormat，官方给出的解释：simple beautiful strong immutable thread-safe。

6. **【强制】** 必须回收自定义的 ThreadLocal 变量，尤其在线程池场景下，线程经常会复用，如果不清理自定义的 ThreadLocal 变量，可能会影响后续业务逻辑和造成内存泄露等问题。变量在使用中使用 try-finally 块进行回收。

**正例**：

```java
objectThreadLocal.set(userInfo);
try {
    // ...
} finally {
    objectThreadLocal.remove();
}
```

7. **【强制】** 高并发时，同步调用应该去考虑锁的性能损耗。能用无锁数据结构，就不要用锁；能锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁。

说明：尽可能使用的代码块工作量尽可能的小，避免在锁代码块中调用 RPC 方法。

8. **【强制】** 对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁。

说明：线程一需要对表 A、B、C 依次全部锁定时可以进行更新操作，那么线程二的加锁顺序也必须是 A、B、C，否则可能出现死锁。

9. **【强制】** 在使用阻塞等待获取锁的方式中，必须在 try 代码块之外，并且在加锁方法与 try 代码块之间没有任何可能抛出异常的方法调用，避免加锁成功后，在 finally 中无法解锁。

说明：如果在 lock 方法与 try 代码块之间的方法调用抛出异常，那么无法解锁，造成其它线程无法成功获取锁。

说明二：如果 lock 方法在 try 代码块之内，可能由于其它方法抛出异常，导致在 finally 代码块中，unlock 对象的锁对象解锁，它会调用 AQS 的 tryRelease 方法（取决于具体实现类），抛出 IllegalMonitorStateException 异常。

说明三：在 Lock 对象的 lock 方法实现中可能抛出 unchecked 异常，产生的后果与说明二相同。

**正例**：

```java
Lock lock = new XxxLock();
// ...
lock.lock();
try {
    doSomething();
    doOthers();
} finally {
    lock.unlock();
}
```

**反例**：

```java
Lock lock = new XxxLock();
// ...
```


---

try {
    // 如果此处抛出异常，则直接执行 finally 代码块
doSomething();
    // 无论前面是否成功，finally 代码块都会执行
    lock.lock();
    doOthers();
} finally {
    lock.unlock();
}

10. **【强制】** 在使用尝试机制来获取锁的方式中，进入业务代码块之前，必须先判断当前线程是否持有锁。锁的释放规则与锁的阻塞等待方式相同。

**说明：** Lock 对象的 unlock 方法在执行时，它会调用 AQS 的 tryRelease 方法（取决于具体实现类），如果当前线程不持有锁，则抛出 IllegalMonitorStateException 异常。

**正例：**

```java
Lock lock = new XxxLock();
// ...
boolean isLocked = lock.tryLock();
if (isLocked) {
    try {
        doSomething();
        doOthers();
    } finally {
        lock.unlock();
    }
}
```

11. **【强制】** 并发修改同一记录时，避免更新丢失，需要加锁。要么在应用层加锁，要么在缓存加锁，要么在数据库层使用乐观锁，使用 version 作为更新依据。

**说明：** 如果每次访问冲突概率小于 20%，推荐使用乐观锁，否则使用悲观锁。乐观锁的重试次数不得小于 3 次。

12. **【强制】** 多线程并行处理定时任务时，Timer 运行多个 TimeTask 时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，使用 ScheduledExecutorService 则没有这个问题。

13. **【推荐】** 资金相关的金融敏感信息，使用悲观锁策略。

**说明：** 乐观锁在数据冲突概率较高的情况下会导致更多的重试，反而降低了性能。另外，乐观锁冲突的解决需要应用层记录日志，处理不当容易造成系统压力或数据异常，资金相关的金融敏感信息不建议使用乐观锁策略。

**正例：** 悲观锁遵循“一锁一到”更新和释放的原则

14. **【推荐】** 使用 CountDownLatch 进行异步任务同步操作，每个线程退出前必须调用 countDown 方法，线程执行代码注意 catch 异常，确保 countDown 方法被执行到，避免主线程无法执行至 await 方法，直到超时才返回结果。

**说明：** 注意，子线程抛出异常堆栈，不能在主线程 try-catch 到。

---

### Java 开发手册

15. **【推荐】** 避免 Random 实例被多线程使用。虽然共享该实例是线程安全的，但会因竞争同一 seed 导致的性能下降。

   说明：Random 实例包括 java.util.Random 的实例或者 Math.random()的方式。

   正例：在 JDK7 之后，可以直接使用 API ThreadLocalRandom，而在 JDK7 之前，需要编写代码保证每个线程持有一个单独的 Random 实例。

16. **【推荐】** 通过双重检查锁（double-checked locking）（在并发场景下）实现延迟初始化的优化问题隐患(可参考 The "Double-Checked Locking is Broken" Declaration)，推荐解决方案中较为简单一种（适用于 JDK5 及以上版本），将目标属性声明为 volatile 型（比如修改 helper 的属性声明为`private volatile Helper helper = null;`）。

   反例：

   ```java
   public class LazyInitDemo {
       private Helper helper = null;

       public Helper getHelper() {
           if (helper == null) {
               synchronized (this) {
                   if (helper == null) {
                       helper = new Helper();
                   }
               }
           }
           return helper;
       }
       // other methods and fields...
   }
   ```

17. **【参考】** volatile 解决多线程中存不存在不可见问题。对于一写多读，是可以解决变量同步问题，但如果多写，同样无法解决线程安全问题。

   说明：如果是 count++操作，使用如下类实现：AtomicInteger count = new AtomicInteger(); count.addAndGet(1); 如果是 JDK8，推荐使用 LongAdder 对象，比 AtomicLong 性能更好（减少乐观锁的重试次数）。

18. **【参考】** HashMap 在容量不够进行 resize 时由于高并发可能出现死链，导致 CPU 飙升，在开发过程中注意规避此风险。

19. **【参考】** ThreadLocal 对象使用 static 修饰，ThreadLocal 无法解决共享对象的更新问题。

   说明：这个变量是当前线程内所有操作共享的，所以设置为静态变量，所有此类实例均共享该变量，也就是说该类第一次被使用时被装载，只需一块存储空间，所以此类对象(只要是这个线程定义的)都可以操控这个变量。

### (八) 控制语句

1. **【强制】** 在一个 switch 块内，每个 case 要么通过 continue/break/return 等来终止，要么注释说明程序将继续执行到哪个 case 为止；在一个 switch 块内，都必须包含一个 default 分支。

---

# (九) 注释规则

1. **【强制】** 类、类属性、类方法的注释必须使用 Javadoc 规范，使用/**内容*/格式，不得使用// xxx 方式。

   说明：在 IDE 编辑窗口中，Javadoc 方式会提示相关注释，生成 Javadoc 可以准确输出相应注释；在 IDE 中，工程调用方法时，不进入方法即可悬浮提示方法、参数、返回值的意义，提高阅读效率。

2. **【强制】** 所有的抽象方法（包括接口中的方法）必须要用 Javadoc 注释，除了返回值、参数、异常说明外，还必须描述该方法做什么事情，实现什么功能。

   说明：对实现类的实现要求，或者调用注意事项，建议一并说明。

3. **【强制】** 所有的类都必须加创建者和创建日期。

   说明：在设置模板时，注意 IDEA 的@author 为${USER}，而 eclipse 的@author 为${user}，大小写有区别，而且日期的设置统一为 yyyy/MM/dd 的格式。

   正例：

   ```
   /**
   * @author yangguanbao
   * @date 2016/10/31
   */
   ```

4. **【强制】** 方法内部单行注释，在被注释语句上方另起一行，使用//注释。方法内部多行注释使用/* 注释，注意与代码对齐。

5. **【强制】** 所有的枚举类型字段必须要有注释，说明每个数据项的用途。

6. **【推荐】** 与其“半吊子”英文来注释，不如用中文注释把问题说清楚。专有名词与关键字保持英文原文即可。

   反例：“TCP 连接超时”解释成“传输控制协议连接超时”，理解反而费脑筋。

7. **【推荐】** 代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑等的修改。

   说明：代码与注释更新不一致，就像是网与导航软件更新不同步一样，如果导航软件不准确指路，就失去了导航的意义。

8. **【推荐】** 在类中删除未使用的任何字段和方法；在方法中删除未使用的任何参数声明与内部变量。

9. **【参考】** 谨慎注释掉代码。在上方详细说明，而不是简单地注释掉。如果无用，则删除。

   说明：代码被注释掉有两种可能性：1）后续会修改此段逻辑。2）永久不用。前者如果没有合适的信息，难以理解消极作用。后者建议直接删除，假如需要查看历史代码，登录版本库即可。

---

# Java 开发手册

**反例**：判断剩余奖品数量等于0时，终止发放奖品，但因为并发处理错误导致奖品数量瞬间变成了负数，这样的话，活动无法终止。

6. **【推荐】** 当某个方法的代码行数超过10行时，return / throw 等中断逻辑的右大括号后加一个空行。

说明：这样能缓解前瞻，有利于代码阅读时重点关注。

7. **【推荐】** 表达异常的分支时，少用 if-else 方式，这种方式可以改写成：

```java
if (condition) {
    // 业务逻辑代码;
    return obj;
}
```

说明：如果非使用 if()...else if()...else...方式表达逻辑，避免后续代码维护困难，请勿超过3层。

**正例**：超过3层的 if-else 的逻辑判断代码可以使用卫语句、策略模式、状态模式等来实现，其中卫语句示例如下：

```java
public void findBoyfriend (Man man){
    if (man.isUgly()) {
        System.out.println("本姑娘是外协协会的资深会员");
        return;
    }
    if (man.isPoor()) {
        System.out.println("贫贱夫妻百事哀");
        return;
    }
    if (man.isBadTemper()) {
        System.out.println("银行有多远，你就给我滚多远");
        return;
    }
    System.out.println("可以先交往一段时间看看");
}
```

8. **【推荐】** 除常用方法（如 getXxx/isXxx）等外，不要在条件判断中执行其它复杂的语句，将复杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性。

说明：很多 if 语句的逻辑表达式书写复杂，与、或、取反混合运算，甚至各种方法深层调用，理解成本非常高。如果赋值一个非常好理解的布尔变量名，则是令人愉心悦目的事情。

**正例**：

```java
final boolean existed = (file.open(fileName, "w") != null) && (...) || (...);
if (existed) {
    // 你的代码
}
```

**反例**：

```java
public final void acquire (long arg){
    if (tryAcquire(arg) &&
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) {
        selfInterrupt();
    }
}
```

---

6. **【推荐】不要在视图模板中加入任何复杂的逻辑。**
   说明：根据 MVC 理论，视图的职责是展示，不要把模型和控制器的活。

7. **【推荐】任何数据结构的构造或初始化，都应指定大小，避免数据结构无限增长吃光内存。**

8. **【推荐】及时清理不再使用的代码段或配置信息。**
   说明：对于垃圾代码或过时配置，坚持清理干净，避免程序过度膨胀，代码冗余。
   正例：对于暂时被注释掉，后续可能恢复使用的代码片断，在注释代码上方，统一规定使用三个斜杠(///)来说明注释掉代码的理由。如：

```java
public static void hello() {
    /// 业务方通知活动暂停
    // Business business = new Business();
    // business.active();
    System.out.println("it's finished");
}
```

## 第27页（处理失败）



---

## (二) 异常处理

1. **[强制]** Java 类库中定义的可以通过预检查方式规避的 RuntimeException 异常不应该通过 catch 的方式来处理，比如：NullPointerException，IndexOutOfBoundsException 等等。
   
   说明：无法通过预检查的异常除外，比如，在解析字符串形式的数字时，可能存在数字格式错误，不得不通过 catch NumberFormatException 来实现。
   
   正例：if (obj != null) {...}
   
   反例：try { obj.method(); } catch (NullPointerException e) {...}

2. **[强制]** 异常不要用于做流程控制，条件控制。
   
   说明：异常设计的初衷是解决程序运行中的各种意外情况，且异常的处理效率比条件判断方式要低很多。

3. **[强制]** catch 时请务必清楚代码和相稳定代码，稳定代码指的是无论如何不会出错的代码。
   
   对于非稳定的代码 catch 尽可能进行分异常类型，再做对应的异常处理。
   
   说明：对大段代码进行 try-catch，使程序无法根据不同的异常做出正确的激烈反应，也不利于定位问题，这是种不负责任的表现。
   
   正例：用户注册的场景中，如果用户输入非法字符，或用户名称长度不在，或用户密码过于简单，在程序上作出不同类型的断言，并提示给用户。

4. **[强制]** 捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃之，如果不想处理它，请将该异常抛给它的调用者。最外层的业务使用者，必须处理异常，将其转化为用户可以理解的内容。

5. **[强制]** 事务场景中，抛出异常被 catch 后，如果需要回滚，一定要注意事务回滚事务。

## 第29页（处理失败）



---

## 二、异常日志

### （一）错误码

1. **【强制】** 错误码的制定原则：快速溯源、简单易记、沟通标准化。
   **说明：** 错误码要想得出于完美和复杂，就像康熙字典中的生僻字一样，用词似乎精雅，但是字典不容易随身携带并且简单易懂。
   **正例：** 错误码回答的问题是谁的？错在哪？1）错误码必须能够快速识别错误来源，可快速判断是谁的问题。2）错误码易于记忆和比对（代码中容易 equals）。3）错误码能够脱离文档和系统平台达到线下轻量化地自由沟通的目的。

2. **【强制】** 错误码不体现版本号和错误等级信息。
   **说明：** 错误码以不断追加的方式进行兼容。错误等级由日志和错误码本身的释义来决定。

3. **【强制】** 全部正常，但不得不填充错误码时返回五个零：00000。

4. **【强制】** 错误码为字符串类型，共5位，分成两个部分：错误产生来源和四位数字编码。
   **说明：** 错误产生来源可以是系统、模块或具体操作，比如结算系统、用户登录校验、库存扣减超时等。四位数字编码可以是自增序列，也可以是根据业务类型定义的固定编码；表示错误级别的数字编码，比如 CDN 服务出错，消息投递超时等问题，四位数字为从0001 到 9999，大类之间步长间距预留 100，参考文档附表 3。

5. **【强制】** 编号不与公司业务架构，更不与组织架构挂钩，一切与平台先到先申请的原则进行，审批生效，编号即被永久固定。

6. **【强制】** 错误码使用者避免随意定义新的错误码。
   **说明：** 尽可能在原有错误码附表中找到语义相同或者相近的错误码在代码中使用即可。

7. **【强制】** 错误码不能直接输出给用户作为提示信息使用。
   **说明：** 错误栈（stack_trace）可以输出信息（error_message）。错误码（error_code），提示信息（user_tip）是一个系统关联并且相对文档独立的整体，但是请勿直接相互组装和使用。

8. **【推荐】** 错误码之外的业务描述信息由 error_message 来承载，而不是让错误码本身涵盖过多具体业务属性。

9. **【推荐】** 在获取第三方服务错误码时，向上抛出允许本系统转义，由 C 转为 B，并且在错误信息上附上原有的第三方错误码。

10. **【参考】** 错误码分为一级宏观错误码、二级宏观错误码、三级宏观错误码。
    **说明：** 在无法明确具体确定的错误原因时，可以直接使用一级宏观错误码，分别是：A0001（用户端错误）。

## 第31页（处理失败）



---

# Java 开发手册

6. **【强制】** finally 块必须对资源对象、流对象进行关闭，有异常也要做 try-catch。

   说明：如果 JDK7 及以上，可以使用 try-with-resources 方式。

7. **【强制】** 不要在 finally 块中使用 return。

   说明：try 块中的 return 语句执行成功后，并不马上返回，而是继续执行 finally 块中的语句，如果此处存在 return 语句，则在此直接返回，无法抛弃 try 块中的返回点。

   反例：

   ```java
   private int x = 0;

   public int checkReturn() {
       try {
           // x 等于 1，此处不返回
           return ++x;
       } finally {
           // 返回的结果是 2
           return ++x;
       }
   }
   ```

8. **【强制】** 捕获异常与抛异常，必须是完全匹配，或者捕获异常是抛异常的父类。

   说明：如果预期对方抛的是经检查异常，实际接到的是运行时异常，就会产生意外情况。

9. **【强制】** 在调用 RPC、二方包、或动态生成类的相关方法时，捕捉异常必须使用 Throwable 类来进行拦截。

   说明：通过反射机制调用方法，如果找不到方法，抛出 NoSuchMethodException。什么情况下抛出 NoSuchMethodError 呢？二方包在类冲突时，仲裁机制可能导致引入非预期的版本使类的方法签名不匹配，或者在字节码修改框架（比如：ASM）动态创建或修改类时，修改了相应的方法签名名。这些情况，即使代码编译器是正确的，但在代码运行期间，会抛出 NoSuchMethodError。

10. **【推荐】** 方法的返回值可以为 null，不强制返回空集合，或者空对象，必须添加注释充分说明什么情况下会返回 null 值。

    说明：本手册明确的 null NPE 是调用者的责任。即使被调用方法返回空集合或者空对象，对调用者来说，也并非毫无忧虑，必须考虑到远程调用失败、序列化失败、运行时异常等场景返回 null 的情况。

11. **【推荐】** 防止 NPE，是程序员的基本修养，注意 NPE 产生的场景：

    1）返回类型为基本数据类型，return 包装数据类型的对象时，自动拆箱有可能产生 NPE。

    反例：

    ```java
    public int f() {
        return Integer对象;
    }
    ```

    如果为 null，自动解箱抛 NPE。

    2）数据集合查询结果可能为 null。

    3）注意数组越界异常。

    4）hashtable 的使用方法 isNotEmpty，取出的数据元素也可能为 null。

    5）一层服务调用的返回值，一律要求进行空指针判断，防止 NPE。

    6）级联调用 obj.getA().getB().getC(); 一连串调用，易产生 NPE。

    正例：使用 JDK8 的 Optional 类来防止 NPE 问题。

---

12. **【推荐】** 定义时区分 unchecked / checked 异常，避免直接抛出 new RuntimeException()，更不允许抛出 Exception 或者 Throwable，应使用有业务含义的自定义异常。推荐业界已定义过的自定义异常，如：DAOException / ServiceException 等。

13. **【参考】** 对于公司外的 http/api 开放接口必须使用 “错误码” ，而应用内部推荐异常抛出；跨应用间 RPC 调用优先考虑使用 Result 方式，封装 isSuccess()方法，“错误码”、“错误简短信息”，而应用内的推荐异常抛出。

说明：关于 RPC 方式返回方式使用 Result 方式的理由：

1）使用抛异常返回方式，调用方如果没有捕获到就会产生运行时错误。

2）如果加错误信息，只是简单的字符串堆栈，加入自己的理解和 error message，对于调用端解决问题的帮助不会太多。如果加了堆信息，在频繁调用出错的情况下，数据序列化传输的性能损耗也是问题。

14. **【参考】** 避免出现重复的代码（Don't Repeat Yourself），即 DRY 原则。

说明：随意复制粘贴代码，必然会导致代码的重复，在以后需要修改时，需要修改所有的副本，容易遗漏。必要时抽取共性方法，或者抽象公共类，甚至是组件化。

**正例：**一个类中有多个 public 方法，都需要进行数行相同的参数校验操作，这个时候请抽取：

```java
private boolean checkParam(DTO dto) {...}
```

### (三) 日志规约

1. **【强制】** 应用中不可直接使用日志系统（Log4j、Logback）中的 API，而应依赖使用日志框架（SLF4J、JCL--Jakarta Commons Logging）中的 API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。

说明：日志框架（SLF4J、JCL--Jakarta Commons Logging）的使用方式（推荐使用 SLF4J）

使用 SLF4J：

```java
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
private static final Logger logger = LoggerFactory.getLogger(Test.class);
```

使用 JCL：

```java
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
private static final Log log = LogFactory.getLog(Test.class);
```

2. **【强制】** 所有日志文件至少保留 15 天，因为有些异常会留以 “周” 为频次发生的特点。对于当天日志，以 “应用名.log” 来保存，保存在/home/admin/应用名/logs/ 目录下，过往日志格式为：{logname}.log.{保存日期}，日期格式：yyyy-MM-dd

> 例如：以 mppserver 应用为例，日志保存在/home/admin/mppserver/logs/mppserver.log，历史日志名为 mppserver.log.2016-08-01

3. **【强制】** 应用中的扩展日志（如打点、临时监控、访问日志等）命名方式：appName_logType_logName.log。logType:日志类型，如 monitor/access 等；logName:日志描述

---

## Java 开发手册

9. **【推荐】** 编写单元测试代码遵守 BCDE 原则，以保证被测试模块的交付质量。
   - **B**: Border，边界值测试，包括循环边界、特殊取值、特殊时间点、数据顺序等。
   - **C**: Correct，正确的输入，获得预期的结果。
   - **D**: Design，与设计文档相结合，来编写单元测试。
   - **E**: Error，强制错误输入场景（如：非法数据、异常流程、业务允许外等），并得到预期的结果。

10. **【推荐】** 对于数据库相关的类的查询、更新、删除等操作，不能假设数据库里的数据是存在的，或者直接将传数据库把数据插入进去，请使用程序插入或者导入数据的方式来准备数据。
   - **反例**: 删除某一行数据的单元测试，在数据库中，先直接手动增加一行作为删除目标，但是这一行新增数据并不符合业务插入规则，导致测试结果异常。

11. **【推荐】** 和数据库相关的单元测试，可以设定自动回滚机制，不给数据库造成脏数据。或者对单元测试产生的数据有明确的前后缀标识。
   - **正例**: 在阿里巴巴企业智能事业部的内部单元测试中，使用 ENTERPRISE_INTELLIGENCE_UNIT_TEST_ 前缀来标识单元测试相关代码。

12. **【推荐】** 对于不可测的代码在适当的时候必要的重构，使代码变得可测，避免为了达到测试要求而书写不规范测试代码。

13. **【推荐】** 在设计评审阶段，开发人员需要和测试人员一起确定单元测试范围，单元测试应覆盖所有测试用例（UC）。

14. **【推荐】** 单元测试作为一种质量保障手段，在项目提测前完成单元测试，不建议项目发布后补充单元测试用例。

15. **【参考】** 为了更方便地进行单元测试，业务代码应避免以下情况：
   - 构造方法中做的事情过多。
   - 存在过多的全局变量和静态方法。
   - 存在过多的内部依赖。
   - 存在过多的条件语句。
   - **说明**: 多层条件语句建议使用卫语句、策略模式、状态模式等方式重构。

16. **【参考】** 不要对单元测试存在如下误解：
   - 那是测试同学干的事情。本文是开发手册，凡是本文内容都是写给同学强相关的。
   - 单元测试代码是多余的，系统的整体功能与各单元部件的测试正常与否是强相关的。
   - 单元测试代码不需要维护。一年半载，那么单元测试可以与开发废弃状态。
   - 单元测试与线上故障没有辨证关系。好的单元测试能极大降低此类线上故障。

---

Java 开发手册

说明：大量地输出无效日志，不利于系统性能提升，也不利于快速定位错误点。记录日志时请思考：这些日志真的有人看吗？看到这条日志你能做什么？能不能给问题排查带来好处？

11. **【推荐】** 可以使用 warn 日志级别来记录用户输入参数错误的情况，避免用户投诉时，无所适从。如非必要，请不要在此场景打出 error 级别，避免频繁报警。

说明：注意日志输出的级别，error 级别只记录系统逻辑出错，异常或者重要的错误信息。

12. **【推荐】** 尽量用英文来描述日志错误信息，如果日志中的错误信息用英文描述不清楚的话使用中文描述即可，否则容易产生歧义。

说明：国际化团队或海外部署的服务如果由于字符编码问题，使用全英文来注释和描述日志错误信息。

---

## 三、单元测试

1. **【强制】好的单元测试必须遵守 AIR 原则。**
   说明：单元测试在线上运行时，感觉像空气（AIR）一样不存在，但在测试质量的保障上，却是非常关键的。好的单元测试被视上说，具有自动化、独立性、可重复执行的特点。
   - **A**: Automatic（自动化）
   - **I**: Independent（独立性）
   - **R**: Repeatable（可重复）

2. **【强制】单元测试应该是全自动执行的，并且非交互式的。**
   测试用例通常是被定期执行的，执行过程必须完全自动化才有意义。输出结果需要人工检查的测试不是一个好的单元测试。单元测试中不准使用 System.out 来进行入内验证，必须使用 assert 来验证。

3. **【强制】保持单元测试的独立性。**
   为了保证单元测试稳定可靠便于维护，单元测试用例之间决不能互相调用，也不能依赖执行的先后次序。
   反例：method2 需要依赖 method1 的执行，将执行结果作为 method2 的输入。

4. **【强制】单元测试是可以重复执行的，不能受到外界环境的影响。**
   说明：单元测试会被放到持续集成中，每次代码 check in 时单元测试都会被执行。如果单元测试依赖外部环境（网络、服务、中间件等）有依赖，导致测试不稳定。
   正例：为了不受外界环境影响，要求设计代码时就把 SUT 的依赖改成注入，在测试时用 spring 这样的 DI 框架注入一个本地（内存）实现或者 Mock 实现。

5. **【强制】对于单元测试，要保证测试粒度足够小，有助于精确定位问题。**
   单测粒度至多是类级别，一般是方法级别。
   说明：只有测试粒度小才能在出错时尽快定位到出错位置。单测不负责检查跨类或者跨系统的交互逻辑，那是集成测试的范畴。

6. **【强制】核心业务、核心应用、核心模块的增量代码必须首先通过单元测试通过。**
   说明：新增代码及时补齐单元测试，如果新增代码影响了原有单元测试，请及时修正。

7. **【强制】单元测试代码必须写在如下工程目录：src/test/java，不允许在业务代码目录下。**
   说明：源码编译器会跳过此目录，确保单元测试框架默认是扫描此目录。

8. **【推荐】单元测试的基本目标：语句覆盖率达到 70%；核心模块的语句覆盖率和分支覆盖率都要达到 100%。**
   说明：在工程的应用分层中提到的 DAO 层，Manager 层，可重用度高的 Service，都应该进行单元测试。

---

10. **【推荐】** 表的命名最好是遵循“业务名称_表的作用”。

    正例：alipay_task / force_project / trade_config

11. **【推荐】** 库名与应用名保持尽量一致。

12. **【推荐】** 如果修改字段含义或对字段表示的状态追加时，需要及时更新字段注释。

13. **【推荐】** 字段允许适当冗余，以提高查询性能，但必须考虑数据一致。冗余字段应遵循：

    1）不是频繁修改的字段。

    2）不是唯一索引的字段。

    3）不是 varchar 超长字段，更不能是 text 字段。

    正例：各业务线经常冗余存储商品名称，避免查询时需要调用 IC 服务获取。

14. **【推荐】** 单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。

    说明：如果预计三年的数据量和表的大小到达这个级别，请要在创建表时就考虑分库分表。

15. **【参考】** 合适的字符串存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。

    正例：无符号值可以避免误存负数，且扩大了表示范围。

| 对象   | 年龄区间  | 类型               | 字节 | 表示范围             |
|--------|-----------|--------------------|------|----------------------|
| 人     | 150 岁之内 | tinyint unsigned   | 1    | 无符号值：0 到 255   |
| 龟     | 数百岁    | smallint unsigned  | 2    | 无符号值：0 到 65535 |
| 恐龙化石 | 数千万年  | int unsigned       | 4    | 无符号值：0 到 43 亿 |
| 太阳   | 约 50 亿年 | bigint unsigned    | 8    | 无符号值：0 到 10 的 19 次方 |

## (二) 索引规约

1. **【强制】** 业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。

    说明：不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的；另外，即使在应用层做了非常完善的校验控制，仍要在表中建立唯一索引，避免程序漏洞，必须依赖数据库产生。

2. **【强制】** 超过三个表禁止 join。需要 join 的字段，数据类型保持绝对一致；多表关联查询时，保证被关联的字段需要有索引。

    说明：即使双表 join 也要注意索引，SQL 性能。

3. **【强制】** 在 varchar 字段上建立索引时，必须指定索引长度，没必要全字段建立索引，根据实际文本区分度来决定索引长度。

---

# Java 开发手册

**说明**: 索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会高达 90%以上，可以使用 count(distinct left(列名, 索引长度))/count(*)的区分度来确定。

4. **[强制]** 页面搜索禁止模糊或者全模糊，如果需要请走搜索引擎来解决。

**说明**: 索引文件具有 B-Tree 的最左前缀匹配性，如果无左前缀的字段，那么无法使用此索引。

5. **[推荐]** 如果有 order by 的场景，请注意利用索引的有序性。order by 最后的字段组合索引的一部分，并且放在索引组合顺序的最后，避免出现 file_sort 的情况，影响查询性能。

**正例**: where a=? and b=? order by c; 索引：a_b_c

**反例**: 索引如果在范围查询，那么索引有序性无法利用，如：WHERE a>10 ORDER BY b; 索引 a_b 无法排序。

6. **[推荐]** 利用覆盖索引来进行查询操作，避免回表。

**说明**: 如果一本书需要知道第 1 章是什么标题，会翻开第 11 章对应的那一页吗？目录浏览一下就好，这个目录就是起到覆盖索引的作用。

**正例**: 能够被索引列的字段必须为查询结果。唯一索引、普通索引三种，而覆盖索引是一种查询的一种效果，用 explain 的结果，extra 列会出现：using index。

7. **[推荐]** 利用延迟关联或者子查询的优化超多分页场景。

**说明**: MySQL 并不是跳过 offset 行，而是取 offset+n 行，然后返回放弃前 offset 行，取 n 行，那么这个操作对时间的耗费，效率率非常的低下，要么控制起因的总页数，要么对超过特定阈值的页数进行 SQL 改写。

**正例**: 先快速定位需要获取的 id 段，然后再关联：

SELECT a.* FROM 表 1 a, (select id from 表 1 where 条件 LIMIT 100000,20 ) b where a.id=b.id

8. **[推荐]** SQL 性能优化的目标：至少要达到 range 级别，要求是 ref 级别，如果可以是 consts 最好。

**说明**:

1）consts 单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即读取到数据。

2）ref 指的是使用普通的索引( normal index)。

3）range 对索引进行范围检索。

**反例**: explain 表的结果，type=index，索引物理文件全扫描，速度非常慢，这个 index 索引比较常还低，与全表扫描几乎没太大差。

9. **[推荐]** 建组合索引的时候，区分度最高的在最左边。

**正例**: 如果 where a=? and b=?，a 列的几乎接近于唯一值，那么需要单建 idx_a 索引即可。

**说明**: 存在年龄字段和姓名字段组合判断条件时，在建索引时，请考虑多条件的前置。如：where c>? and d=? 那么 d 的区分度更高，也必须 d 放在索引的最前列，即建立组合索引 idx_d_c。

10. **[推荐]** 防止因字段类型不同造成的隐式转换，导致索引失效。

---

# 五、MySQL 数据库

## (一) 建表规约

1. **[强制]** 表达是否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinyint（1 表示是，0 表示否）。
   
   说明：任何字段如果为非负数，必须是 unsigned。
   
   注意：POJO 类的任何布尔类型的变量，都不要加 is 前缀，所以，需要在 <resultMap> 设置从 is_xxx 到 Xxx 的映射关系。数据库表示是否的值，使用 tinyint 类型，坚持 is_xxx 的命名方式是为了明确其值含义取值范围。
   
   正例：表达逻辑删除的字段名 is_deleted，1 表示删除，0 表示未删除。

2. **[强制]** 表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名需要慎重考虑。
   
   说明：MySQL 在 Windows 下不区分大小写，但在 Linux 下默认区分大小写。因此，数据库名、表名、字段名，都不允许出现任何大写字母，避免产生歧义。
   
   正例：aliyun_admin，rdc_config，level3_name
   
   反例：AliyunAdmin，rdcConfig，level_3_name

3. **[强制]** 表名不使用复数名词。
   
   说明：表名应该仅仅表示表里面的实体内容，不应该表示实体数量，对应于 DO 类名也是单数形式，符合表达习惯。

4. **[强制]** 禁用保留字，如 desc、range、match、delayed 等，请参考 MySQL 官方保留字。

5. **[强制]** 主键索引名为 pk_字段名；唯一索引名为 uk_字段名；普通索引名则为 idx_字段名。
   
   说明：pk 即 primary key；uk 即 unique key；idx 即 index 的简称。

6. **[强制]** 小数类型为 decimal，禁止使用 float 和 double。
   
   说明：在存储的时候，float 和 double 都会有精度损失的问题，很可能在比较值的时候，得到不正确的结果。如果存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数部分分开存储。

7. **[强制]** 如果存储的字符串长度超过 255 字节，使用 text 类型存储。

8. **[强制]** varchar 是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长度大于此值，定为 text 类型字段，独立出来一张表，用主键对应，避免影响其它字段索引效率。

9. **[强制]** 表必备三字段：id, gmt_create, gmt_modified。
   
   说明：其中 id 为主键，类型为 bigint unsigned，单表时自增，步长为 1，gmt_create, gmt_modified 的类型均为 datetime 类型，前者现在时表示初始化，后者过去时表示更新。


## 第40页（处理失败）



## 第41页（处理失败）



---

### (三) SQL 语句

1. **【强制】** 不要使用 count(列名)或 count(常量)来替代 count(*)，count(*)是 SQL92 定义的标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。
   说明：count(*)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行。

2. **【强制】** count(distinct col) 计算该列除 NULL 之外的不重复行数 注意 count(distinct col1, col2) 如果其中一列全为 NULL，那么即使另一列有不同的值，也返回 0。

3. **【强制】** 当某一列的值全是 NULL 时，count(col)的返回结果为 0，但 sum(col)的返回结果为 NULL，因此使用 sum()时需注意 NPE 问题。
   正例：可以使用如下方式避免 sum 的 NPE 问题：SELECT IFNULL(SUM(column), 0) FROM table;

4. **【强制】** 使用 ISNULL()来判断是否为 NULL 值。
   说明：NULL 与任何值的比较结果为 NULL。
   1）NULL<>NULL 的返回结果是 NULL，而不是 false。
   2）NULL=NULL 的返回结果是 NULL，而不是 true。
   3）NULL<>1 的返回结果是 NULL，而不是 true。
   反例：在 SQL 语句中，如果在 null 前换行，影响可读性。select * from table where column1 is null and column3 is not null; 而 `ISNULL(column)` 是一个整数，简洁易懂，几性能数据上分析，`ISNULL(column)` 执行效率更快一些。

5. **【强制】** 代码中写分页查询逻辑时，若 count 为 0 应直接返回，避免执行后面的分页语句。

6. **【强制】** 不得使用外键与级联，一切外键概念必须在应用层解决。
   说明：（概念解释）学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果要新增学生时先插入 student_id，同时触发成绩表的新增行操作，更新，即为级联更新。外键与级联更新用于单机低并发，不适合分布式、高并发系统，级联更新是强阻塞，存在数据库系统风暴的风险；外键影响数据库的插入速度。

7. **【强制】** 禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。

8. **【强制】** 数据订正（特别是删除能够恢复记录操作）时，要先 select，避免出现误删除，确认无误才能执行更新语句。

---

## (二) 二方库依赖

1. **[强制]** 定义 GAV 遵从以下规则：
   1) **GroupID** 格式：com.(公司/BU).业务线[.子业务线]，最多 4 级。
      说明：{公司/BU} 例如：alibaba/taobao/tmall/aliexpress 等 BU 一级；子业务线可选。
      正例：com.taobao.jstorm 或 com.alibaba.dubbo.register
   2) **ArtifactID** 格式：产品线名-模块名。语义不重复不漏漏，先到中央仓库去查证一下。
      正例：dubbo-client / fastjson-api / jstorm-tool
   3) **Version**：详细规定参考下方。

2. **[强制]** 二方库版本号命名方式：主版本号.次版本号.修订号
   1) 主版本号：产品方向改变，或者大规模 API 不兼容，或者架构不兼容升级。
   2) 次版本号：保持相对兼容性，增加主要功能特性，影响范围极小的 API 不兼容修改。
   3) 修订号：保持完全兼容性，修复 BUG，新增微小更功能特性等。
      说明：注意起始版本号必须为：1.0.0，而不是 0.0.1。
      反例：仓库内某二方库版本从 1.0.0.0 开始，一直顺眼“升级”成 1.0.0.4，完全失去版本的语义信息。

3. **[强制]** 线上应用不要依赖 SNAPSHOT 版本（安全包除外）；正式发布的类库必须先去中央仓库进行验证，促 RELEASE 版本号有延迟性，且版本号不允许覆盖重发。
      说明：对于 SNAPSHOT 版本是允许相互依赖的，但必须在发布前去掉 SNAPSHOT 版本号。另外，中央仓库可以加快编译时的打包构建。

4. **[强制]** 二方库的新增或升级，保持版本的绝对之外的其它 jar 包仲载结果不变。如果有改变，必须明确评估和验证。
      说明：在升级时，进行 dependency:resolve 前后信息比对，如果仲载结果完全不一致，那么通过 dependency:tree 命令，找出差异点，进行<exclude>排除 jar 包。

5. **[强制]** 二方库里可以定义枚举类型，参数可以使用枚举类型，但是接口返回值不允许使用枚举类型或者包含枚举类型的 POJO 对象。

---

### Java 开发手册

3. **【强制】** 不要用 resultClass 当返回参数，即使所有类属性名与数据库字段一一对应，也需要定义 `<resultMap>`；反过来，每一个表也必然有一个 `<resultMap>` 与之对应。
   **说明：** 配置映射关系，使字段与 DO 类解藕，方便维护。

4. **【强制】** sql.xml 配置参数使用：#{}，#param# 不要使用${} 此种方式容易出现 SQL 注入。

5. **【强制】** iBATIS 自带的 queryForList(String statementName,int start,int size) 不推荐使用。
   **说明：** 其实就是定位到数据库取到 statementName 对应的 SQL 语句的所有记录，再通过 subList 取 start,size 的子集合。
   **正例：**
   ```java
   Map<String, Object> map = new HashMap<>();
   map.put("start", start);
   map.put("size", size);
   ```

6. **【强制】** 不允许直接拿 HashMap 与 Hashtable 作为查询结果集的输出。
   **反例：** 某同学为避免写一个 `<resultMap>`，直接使用 HashTable 来接收数据库返回结果；结果出现日常是想 bigint 转成 Long 值，而线上由于数据库版本不一样，解析成 BigInteger，导致线上问题。

7. **【强制】** 更新数据表记录时，必须同时更新记录对应的 gmt_modified 字段值为当前时间。

8. **【推荐】** 不要写一个大而全的数据更新接口。传入为 POJO 类，不管是不是自己的目标更新字段，都进行 update table set c1=value1,c2=value2,c3=value3；这是不对的。执行 SQL 时，不要更新无改动的字段，一是易出错；二是效率低；三是增加 binlog 存储。

9. **【参考】** @Transactional 事务不要滥用。事务会影响数据库的 QPS，另外使用事务的地方需要考虑各方面的回滚方案，包括缓存回滚、搜索引擎回滚、消息补偿、统计修正等。

10. **【参考】** `<isEqual>` 中的 compareValue 是与属性值对比的常量，一般是数字，表示相等时带上此条件；`<isNotEmpty>` 表示不为空且不为 null 时执行；`<isNotNull>` 表示不为 null 值时执行。

---

Java 开发手册

3. **【推荐】** 给 JVM 环境参数设置 -XX:+HeapDumpOnOutOfMemoryError 参数，让 JVM 碰到 OOM 场景时输出 dump 信息。
   说明：OOM 的发生是有概率的，甚至相隔数月才出现一例，出错时的堆内信息对解决问题非常有帮助。

4. **【推荐】** 在线上生产环境，JVM 的 Xms 和 Xmx 设置一样大的内存容量，避免在 GC 后调整堆大小带来的压力。

5. **【参考】** 服务器内部重定向必须使用 forward；外部重定向地址必须使用 URL Broker 生成，否则因线上采用 HTTPS 协议而导致浏览器提示“不安全”。此外，还会带来 URL 维护不一致的问题。

---

# 七、设计规约

1. **【强制】存储方案和底层数据结构**的设计获得评审一致通过，并沉淀为文档。
   
   说明：有缺陷的底层数据结构会导致系统负载上升，可扩展性下降，埋坑为他会因历史数据迁移和系统平滑过渡而陡然增加。所以，存储方案和数据结构需要认真地进行设计和评审，生产环境提交执行后，需要进行double check。
   
   正例：评审内容包括存储介质选择，表结构设计能否满足技术方案，取性能和扩储空间能否满足业务发展，表或字段之间的耦合性，字段名称，字段类型，索引等；数据结构的变更（如在原有表中新增加字段）也需要进行评审通过后上线。

2. **【强制】在需求分析阶段，如果与系统交互的User超过**一类并且相关的User Case超过**5个，使用用例图来表达更加清晰的结构化需求。

3. **【强制】如果某个业务对象的状态超过**3个，使用状态图来表达并且明确状态变化的各个触发条件。
   
   说明：状态图的核心是对象状态，首先明确对象有多少种状态，然后明确两状态之间是否存在直接转换关系，再明确触发状态转换的条件是什么。
   
   正例：订单状态有下单、待付款、已付款、待发货、已发货、已收货等。比如订单与收货这两种状态之间是不可能有直接转换关系的。

4. **【强制】如果系统中某个功能的调用链路上的涉及对象超过**3个，使用时序图来表达并且明确各调用环节的输入与输出。
   
   说明：时序图反映了一系列对象间的交互与动作关系，清晰立体地反映系统的调用纵深链路。

5. **【强制】如果系统中模型类超过**5个，并且存在复杂的依赖关系，使用类图来表达并且明确类之间的关系。
   
   说明：类图像建筑领域的施工图，如果搭桥平房，可能不需要，但如果建造高楼Z空间大楼，肯定需要详细的施工图纸。

6. **【强制】如果系统中超过**2个对象之间存在协作关系，并且需要表示对象的处理流程，使用活动图来表示。
   
   说明：活动图是流程图的扩展，增加了能够体现协作关系的对象流，支持表示并发等。

7. **【推荐】系统架构设计时明确以下目标：
   
   - 确定系统边界。确定系统在技术层面的做与不做。
   - 确定系统内模块之间的关系。确定模块之间的依赖关系及模块的宏观输入与输出。
   - 确定部署后续设计与测试的内容。使后续的子系统设计能够在一个既定的框架内和技术方向上继续演化。

---

# Java 开发手册

- 确定非功能性需求。非功能性需求是指安全性、可用性、可扩展性等。

8. **[推荐]** 需求分析与系统设计在考虑主干功能的同时，需要充分评估异常流程与业务边界。
   反例：用户在淘宝中浏览过程中，银行扣款成功，发送给用户扣款成功短信，但是支付宝款项由于断网系统产生异常，淘宝订单页面依然显示未付款，导致用户投诉。

9. **[推荐]** 类在设计与实现时要符合单一原则。
   说明：单一原则最易理解却是最难实现的一条原则，随着系统演进，很多时候，忘记了类设计的初衷。

10. **[推荐]** 谨慎使用继承的方式来进行扩展，优先使用聚合/组合的方式来实现。
    说明：不得已使用继承的场，必须符合里氏代换原则，此原则说父类能够出现的地方子类一定能够出现，比如，“把钱交出来”，钱的子类美元、欧元、人民币等都可以出现。

11. **[推荐]** 系统设计阶段，根据依赖倒置原则，尽量依赖抽象类与接口，有利于扩展与维护。
    说明：低层次模块依赖于高层次模块的抽象，方便系统间的解藕。

12. **[推荐]** 系统设计阶段，注意对扩展开放，对修改闭合。
    说明：极端情况下，支持的代码是不可修改的，同一业务场景的需求变化，通过模块类的扩展来实现。

13. **[推荐]** 系统设计阶段，共性业务或公共行为抽取出来公共模块、公共配置、公共类、公共方法等，系统中不出现重复代码。
    说明：随着业务的重复次数越多，维护成本指数级上升。

14. **[推荐]** 避免如下误解：敏捷开发 = 讲故事 + 编码 + 发布。
    说明：敏捷开发是快速交付迭代可用的系统，省略多余的设计方案，摒弃传统的审批流程，但核心关键点上的必要设计和文档沉淀是需要的。
    反例：某团队为了业务快速发展，敏捷成了只需经理催进度的借口，系统中均是勉强能运行但像原始人一样的代码，可维护性和可扩展性极差，一年之后，不得不进行大规模重构，得不偿失。

15. **[参考]** 设计文档的作用是明确需求，理顺逻辑，周期维护，次要目的用于指导编码。
    说明：避免为了写设计文档，系统设计文档背后有明确的系统维护和管理目的，所以设计结果需要进行分类归档保存。

16. **[参考]** 可扩展性的本质是找到系统的变化点，并隔离变化点。
    说明：世间众多设计模式其实就是一种找出模式即隔离变化点的模式。
    正例：极致扩展的系统，就是需求的变化不会在原有代码中对物理上进行任何的修改。

17. **[参考]** 设计的本质就是识别和表达系统类点。
    说明：识别和表达类是至关重要的，很多人错误地认为识别系统类点在哪里，表达只是自然然的事情，但是事实上很多系统类点是难以被看清，甚至是认为为无关紧要的类点。

---

力：表达规则和表达工具的熟练性、抽象思维和总结能力的局限性、基础知识体系的完整性、深入浅出的主动表达力。

18. **[参考] 代码即文档的观点是错误的**，清晰的代码只是文档的某个片断，而不是全部。

说明：代码的深奥理解、模块层面上的依赖关系网、业务场景逻辑，非功能性需求等问题是需要相应的文档来完整地呈现的。

19. **[参考] 在做无障碍产品设计时，需要考虑到**：

- 所有可交互的控件元素必须能够被 tab 键聚焦，并且焦点顺序符合自然操作逻辑。
- 用于登陆校验和请求栏载的验证码均需提供图形验证码以外的其它方式。
- 自定义的控件类型需明确交互方式。

**正例**：用户登陆场景中，输入框的按钮都需要考虑 tab 键聚焦，符合自然逻辑的操作顺序如下，“输入用户名，输入密码，输入验证码，点击登录”，其中验证码实现语音验证方式。如果有自定义标签实现的控件设置控件类型可使用 role 属性。

---

# 附1：版本历史

| 版本号 | 版本名 | 发布日期   | 备注 |
|--------|--------|------------|------|
| --     | --     | 2016.12.07 | 试读版本首次对外发布 |
| 1.0.0  | 正式版 | 2017.02.09 | 阿里巴巴集团正式对外发布 |
| 1.0.1  | --     | 2017.02.13 | 1）修正 String[] 的前后矛盾。<br>2）vm 修正成 velocity。<br>3）修正 countdown 描述错误。 |
| 1.0.2  | --     | 2017.02.20 | 1）去除文底水印。<br>2）数据类型中引用太阳历年终问题。<br>3）修正关于异常和方法签名的部分描述。<br>4）修正 final 描述。<br>5）去除 Comparator 部分描述。 |
| 1.1.0  | --     | 2017.02.27 | 1）增加前言。<br>2）增加 <? extends T> 描述和说明。<br>3）增加版本历史。<br>4）增加存有名词解释。 |
| 1.1.1  | --     | 2017.03.31 | 修正页码总数和部分示例。 |
| 1.2.0  | 完美版 | 2017.05.20 | 1）根据云栖社区的“聚能聊” 活动反馈，对手册的页码、排版、描述进行修正。<br>2）增加 final 的适用场景描述。<br>3）增加关于锁的描述。<br>4）增加“指定集合大小”的详细说明以及示例。<br>5）增加正则示例代码。<br>6）明确数据库示例中删除您的字段名为 is_deleted |
| 1.3.0  | 终极版 | 2017.09.25 | 增加单元测试说明，阿里开源的 IDE 代码规范检测插件： [点击下载](#) |
| 1.3.1  | 纪念版 | 2017.11.30 | 修正部分描述；采用阿里 P3C 开源 IDE 检测插件相同的 Apache2.0 协议。 |
| 1.4.0  | 详尽版 | 2018.05.20 | 增加设计规约大类，共 16 条。 |

## 第50页（处理失败）



## 第51页（处理失败）



---

### 附 3：错误码列表

| 错误码 | 中文描述 | 说明 |
|--------|----------|------|
| 00000  | 一切 ok | 正确执行后的返回 |
| A0001  | 用户端错误 | 一级宏观错误码 |
| A0100  | 用户注册错误 | 二级宏观错误码 |
| A0101  | 用户未同意隐私协议 | |
| A0102  | 注册国家或地区受限 | |
| A0110  | 用户名校验失败 | |
| A0111  | 用户名已存在 | |
| A0112  | 用户名包含敏感词 | |
| A0113  | 用户名包含特殊字符 | |
| A0120  | 密码校验失败 | |
| A0121  | 密码长度不够 | |
| A0122  | 密码强度不够 | |
| A0130  | 校验码输入错误 | |
| A0131  | 短信校验码输入错误 | |
| A0132  | 邮件校验码输入错误 | |
| A0133  | 语音校验码输入错误 | |
| A0140  | 用户证件异常 | |
| A0141  | 用户证件类型未选择 | |
| A0142  | 大陆身份证编号校验非法 | |
| A0143  | 护照编号校验非法 | |
| A0144  | 军官证编号校验非法 | |
| A0150  | 用户基本信息校验失败 | |
| A0151  | 手机格式校验失败 | |
| A0152  | 地址格式校验失败 | |
| A0153  | 邮箱格式校验失败 | |
| A0200  | 用户登录异常 | 二级宏观错误码 |
| A0201  | 用户账户不存在 | |

---



---

# Java 开发手册

| 编码 | 描述 |
|------|------|
| A0410 | 请求必填参数为空 |
| A0411 | 用户订单号为空 |
| A0412 | 订购数量为空 |
| A0413 | 缺少时间戳参数 |
| A0414 | 非法的时间戳参数 |
| A0420 | 请求参数值超出允许的范围 |
| A0421 | 参数格式不匹配 |
| A0422 | 地址不在服务范围 |
| A0423 | 时间不在服务范围 |
| A0424 | 金额超出限制 |
| A0425 | 数量超出限制 |
| A0426 | 请求批量处理总个数超出限制 |
| A0427 | 请求 JSON 解析失败 |
| A0430 | 用户输入内容非法 |
| A0431 | 包含违法敏感词 |
| A0432 | 图片包含违法信息 |
| A0433 | 文件侵犯版权 |
| A0440 | 用户操作异常 |
| A0441 | 用户支付超时 |
| A0442 | 确认订单超时 |
| A0443 | 订单已关闭 |
| A0500 | 用户请求服务异常 | 二级宏观错误码 |
| A0501 | 请求次数超出限制 |
| A0502 | 请求并发数超出限制 |
| A0503 | 用户操作请等待 |
| A0504 | WebSocket 连接异常 |
| A0505 | WebSocket 连接断开 |
| A0506 | 用户重复请求 |
| A0600 | 用户资源异常 | 二级宏观错误码 |
| A0601 | 账户余额不足 |


---

# Java 开发手册

| 编号   | 描述                     | 备注               |
|--------|--------------------------|--------------------|
| A0602  | 用户磁盘空间不足         |                    |
| A0603  | 用户内存空间不足         |                    |
| A0604  | 用户 OSS 容量不足        |                    |
| A0605  | 用户配额已用光           | 蚂蚁森林浇水次数或每天抽奖数 |
| A0700  | 用户上传文件异常         | 二级宏观错误码     |
| A0701  | 用户上传文件类型不匹配   |                    |
| A0702  | 用户上传文件太大         |                    |
| A0703  | 用户上传图片太大         |                    |
| A0704  | 用户上传视频太大         |                    |
| A0705  | 用户上传压缩文件太大     |                    |
| A0800  | 用户当前版本异常         | 二级宏观错误码     |
| A0801  | 用户安装版本与系统不匹配 |                    |
| A0802  | 用户安装版本过低         |                    |
| A0803  | 用户安装版本过高         |                    |
| A0804  | 用户安装版本已过期       |                    |
| A0805  | 用户 API 请求版本不匹配  |                    |
| A0806  | 用户 API 请求版本过高    |                    |
| A0807  | 用户 API 请求版本过低    |                    |
| A0900  | 用户隐私未授权           | 二级宏观错误码     |
| A0901  | 用户隐私未签署           |                    |
| A0902  | 用户摄像头未授权         |                    |
| A0903  | 用户相机未授权           |                    |
| A0904  | 用户图片库未授权         |                    |
| A0905  | 用户文件未授权           |                    |
| A0906  | 用户位置信息未授权       |                    |
| A0907  | 用户通讯录未授权         |                    |
| A1000  | 用户设备异常             | 二级宏观错误码     |
| A1001  | 用户相机异常             |                    |
| A1002  | 用户麦克风异常           |                    |
| A1003  | 用户听筒异常             |                    |

---



---

# Java 开发手册

| 错误代码 | 错误描述 | 备注 |
|----------|----------|------|
| C0130 | 缓存服务出错 | |
| C0131 | key 长度超过限制 | |
| C0132 | value 长度超过限制 | |
| C0133 | 存储容量已满 | |
| C0134 | 不支持的数据格式 | |
| C0140 | 配置服务出错 | |
| C0150 | 网络资源服务出错 | |
| C0151 | VPN 服务出错 | |
| C0152 | CDN 服务出错 | |
| C0153 | 域名解析服务出错 | |
| C0154 | 网关服务出错 | |
| C0200 | 第三方系统执行超时 | 二级宏观错误码 |
| C0210 | RPC 执行超时 | |
| C0220 | 消息投递超时 | |
| C0230 | 缓存服务超时 | |
| C0240 | 配置服务超时 | |
| C0250 | 数据库服务超时 | |
| C0300 | 数据库服务出错 | 二级宏观错误码 |
| C0311 | 表不存在 | |
| C0312 | 列不存在 | |
| C0321 | 多表关联中存在多个相同名称的列 | |
| C0331 | 数据库死锁 | |
| C0341 | 主键冲突 | |
| C0400 | 第三方系统服务被触发 | 二级宏观错误码 |
| C0401 | 第三方系统熔断 | |
| C0402 | 第三方功能降级 | |
| C0500 | 通知服务出错 | 二级宏观错误码 |
| C0501 | 短信提醒服务失败 | |
| C0502 | 语音提醒服务失败 | |
| C0503 | 邮件提醒服务失败 | |

## 第58页（处理失败）



## 第59页（处理失败）



## 第60页（处理失败）



---

Java 开发手册

扫码加阿里妹
海量资源免费领

逛阿里云开发者社区
九大技术领域从入门到精通